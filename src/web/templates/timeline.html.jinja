{% extends "base.html.jinja" %}
{% from "components/ui.html.jinja" import button, section_heading %}
{% block title %}
    PlexAniBridge - {{ profile }}
{% endblock title %}
{% block content %}
    <div x-data="timeline('{{ profile }}')" x-init="init()" class="space-y-6">
        <!-- Header / Actions -->
        <div>
            {{ section_heading('lucide:history','Sync Timeline','Profile: <span class="font-medium text-slate-300" x-text="profile"></span>',
                        button('Full Sync','success','sm',None,None,False,'','@click="sync(false)"') ~
            button('Poll Sync','primary','sm',None,None,False,'','@click="sync(true)"') ~
            button('Reload','neutral','sm',None,None,False,'','@click="reload()"') ) }}
        </div>
        <!-- Stats -->
        <div class="grid gap-3 grid-cols-2 md:grid-cols-3 lg:grid-cols-6">
            <template x-for="(v,k) in orderedStats()" :key="k">
                <div @click="toggleOutcomeFilter(k)"
                     :class="[ 'relative rounded-md p-3 overflow-hidden group cursor-pointer select-none transition', outcomeFilter===k ? 'border-sky-500 ring-1 ring-sky-400/60 bg-sky-950/40' : 'border border-slate-800 hover:border-slate-700 bg-gradient-to-br from-slate-900/70 to-slate-800/30' ]"
                     :title="outcomeFilter===k ? 'Click to remove filter' : 'Filter by ' + outcomeLabel(k)">
                    <div class="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity bg-[radial-gradient(circle_at_30%_30%,rgba(255,255,255,0.05),transparent)]">
                    </div>
                    <div class="text-[10px] uppercase tracking-wide text-slate-400 font-medium"
                         x-text="outcomeLabel(k)"></div>
                    <div class="mt-1 text-2xl font-semibold tabular-nums" x-text="v"></div>
                    <div x-show="outcomeFilter===k" class="absolute top-1 right-1">
                        <span class="inline-flex items-center gap-0.5 mr-1 px-1 py-0.5 rounded bg-sky-600/70 text-[9px] font-semibold text-white">
                            <iconify-icon icon="lucide:filter" inline></iconify-icon>
                            Active
                        </span>
                    </div>
                </div>
            </template>
        </div>
        <!-- Active Filter Notice -->
        <div x-show="outcomeFilter"
             class="text-[11px] text-slate-400 flex items-center gap-2">
            <div>
                Filtering by
                <span class="font-semibold text-slate-200"
                      x-text="outcomeLabel(outcomeFilter)"></span>
            </div>
            <button @click="outcomeFilter=null"
                    class="px-1.5 py-0.5 rounded bg-slate-800 hover:bg-slate-700 text-sky-300 text-[10px] font-medium flex items-center gap-1">
                <iconify-icon icon="lucide:x" inline></iconify-icon>
                Clear
            </button>
        </div>
        <!-- Infinite Scroll Notice -->
        <div class="flex items-center gap-2 text-[11px] text-slate-500"
             x-show="items.length">
            <span class="inline-flex items-center gap-1"><iconify-icon icon="lucide:infinity" inline></iconify-icon> Scroll to load older history</span>
            <template x-if="loadingMore"><span class="inline-flex items-center gap-1 text-sky-300"><iconify-icon icon="lucide:loader-2" class="animate-spin" inline></iconify-icon> Loading…</span></template>
            <template x-if="allLoaded && !loadingMore"><span class="inline-flex items-center gap-1 text-emerald-400"><iconify-icon icon="lucide:check" inline></iconify-icon> All loaded</span></template>
        </div>
        <!-- Timeline Items -->
        <div class="space-y-4" x-show="filteredItems().length">
            <template x-for="item in filteredItems()" :key="item.id">
                <div x-data="{ open:false }"
                     class="rounded-md border border-slate-800 bg-slate-900/60 backdrop-blur-sm overflow-hidden shadow-sm hover:shadow-md transition-shadow">
                    <div class="flex gap-4 p-4">
                        <!-- Outcome Bar -->
                        <div class="w-1 rounded-md" :class="badgeColor(item.outcome)"></div>
                        <!-- Cover -->
                        <div class="w-14 shrink-0 flex items-start" x-show="item.anilist_id">
                            <template x-if="media[item.anilist_id] && !media[item.anilist_id]._error">
                                <a :href="anilistUrl(item)" target="_blank" rel="noopener">
                                    <img :src="media[item.anilist_id]?.coverImage?.medium"
                                         class="w-14 h-20 object-cover rounded-md ring-1 ring-slate-700/50 cursor-pointer"
                                         :alt="displayTitle(item)"
                                         width="56"
                                         height="80" />
                                </a>
                            </template>
                            <template x-if="!media[item.anilist_id] || media[item.anilist_id]._error">
                                <div class="w-14 h-20 flex items-center justify-center rounded-md bg-slate-800 text-slate-500 text-[10px] text-center leading-tight px-1">
                                    <span x-text="media[item.anilist_id]?._error ? 'AniList\nError' : 'No\nCover'"></span>
                                </div>
                            </template>
                        </div>
                        <!-- Plex Cover (fallback when no AniList) -->
                        <div class="w-14 shrink-0 flex items-start"
                             x-show="!item.anilist_id && item.plex_guid">
                            <template x-if="plexMedia[item.plex_guid] && !plexMedia[item.plex_guid]._error && plexMedia[item.plex_guid].thumb">
                                <a :href="plexUrl(item)" target="_blank" rel="noopener">
                                    <img :src="plexMedia[item.plex_guid].thumb"
                                         class="w-14 h-20 object-cover rounded-md ring-1 ring-slate-700/50 cursor-pointer"
                                         :alt="displayTitle(item)"
                                         width="56"
                                         height="80" />
                                </a>
                            </template>
                            <template x-if="!plexMedia[item.plex_guid] || plexMedia[item.plex_guid]._error || !plexMedia[item.plex_guid].thumb">
                                <div class="w-14 h-20 flex items-center justify-center rounded-md bg-slate-800 text-slate-500 text-[10px] text-center leading-tight px-1">
                                    <span x-text="plexMedia[item.plex_guid]?._error ? 'Plex\nError' : 'No\nCover'"></span>
                                </div>
                            </template>
                        </div>
                        <!-- Main Content -->
                        <div class="flex-1 min-w-0">
                            <div class="flex flex-wrap items-center gap-2">
                                <span class="font-medium truncate" x-text="displayTitle(item)"></span>
                                <!-- Title Source Badge -->
                                <span class="inline-flex items-center gap-1 px-1 py-0.5 rounded-md text-[9px] font-semibold tracking-wide border"
                                      :class="titleSource(item)==='AniList' ? 'bg-sky-700/40 text-sky-100 border-sky-600/50' : titleSource(item)==='Plex' ? 'bg-amber-700/40 text-amber-100 border-amber-600/50' : 'bg-slate-700/40 text-slate-200 border-slate-600/50'"
                                      x-text="titleSource(item)"></span>
                                <span class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-md text-[10px] font-medium tracking-wide"
                                      :class="badgeColor(item.outcome)">
                                    <iconify-icon :icon="`lucide:${outcomeIcon(item.outcome)}`" inline></iconify-icon>
                                    <span x-text="outcomeLabel(item.outcome)"></span>
                                </span>
                                <span class="text-xs text-slate-400">
                                    <span x-text="new Date(item.timestamp).toLocaleString()"></span>
                                </span>
                            </div>
                            <div class="mt-1 flex flex-wrap gap-x-1.5 gap-y-1 text-[11px] text-slate-400">
                                <span class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-md border border-slate-700 bg-slate-800/70 text-slate-300 font-medium uppercase tracking-wide"
                                      x-text="item.plex_type"></span>
                                <!-- AniList Chip -->
                                <template x-if="item.anilist_id">
                                    <a :href="anilistUrl(item)"
                                       target="_blank"
                                       rel="noopener"
                                       class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-md border border-slate-700 bg-slate-800/70 hover:bg-slate-700 text-slate-300 transition-colors">
                                        <iconify-icon icon="lucide:external-link" inline></iconify-icon>
                                        <span class="font-medium" x-text="'AniList ' + item.anilist_id"></span>
                                    </a>
                                </template>
                                <!-- Plex Chip (uses rating key link if available) -->
                                <template x-if="item.plex_guid">
                                    <template x-if="plexUrl(item)">
                                        <a :href="plexUrl(item)"
                                           target="_blank"
                                           rel="noopener"
                                           class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-md border border-slate-700 bg-slate-800/70 hover:bg-slate-700 text-slate-300 transition-colors truncate max-w-[12rem]">
                                            <iconify-icon icon="lucide:external-link" inline></iconify-icon>
                                            <span class="font-medium" x-text="'Plex ' + shortGuid(item.plex_guid)"></span>
                                        </a>
                                    </template>
                                    <template x-if="!plexUrl(item)">
                                        <span class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-md border border-slate-800 bg-slate-900/40 text-slate-500 truncate max-w-[12rem]">
                                            <iconify-icon icon="lucide:link" inline></iconify-icon>
                                            <span class="font-medium" x-text="'Plex ' + shortGuid(item.plex_guid)"></span>
                                        </span>
                                    </template>
                                </template>
                            </div>
                            <div class="mt-1 text-[11px] text-red-400"
                                 x-show="item.error_message"
                                 x-text="item.error_message"></div>
                            <div class="mt-2"
                                 x-show="item.outcome==='synced' && (item.before_state || item.after_state)">
                                <button @click.stop="open=!open"
                                        class="text-xs text-sky-400 hover:text-sky-300 flex items-center gap-1">
                                    <iconify-icon :icon="open ? 'lucide:minus-square' : 'lucide:plus-square'" inline></iconify-icon>
                                    <span x-text="open ? 'Hide diff' : 'Show diff'"></span>
                                </button>
                            </div>
                        </div>
                        <div class="flex items-start"
                             x-show="item.outcome==='synced' && (item.before_state || item.after_state)">
                            <iconify-icon :icon="open ? 'lucide:chevron-up' : 'lucide:chevron-down'" @click.stop="open = !open" class="text-slate-500 cursor-pointer" inline></iconify-icon>
                        </div>
                    </div>
                    <!-- Diff Section -->
                    <div x-show="open && item.outcome==='synced' && (item.before_state || item.after_state)"
                         x-transition.opacity
                         class="border-t border-slate-800 bg-slate-950/80">
                        <div class="p-4" x-data="diffViewer(item)">
                            <!-- Toolbar / Tabs -->
                            <div class="flex flex-wrap items-center gap-3 mb-3">
                                <div class="flex items-center rounded-md overflow-hidden border border-slate-700/70 bg-slate-900/60 text-[11px]">
                                    <button @click="tab='changes'"
                                            :class="tab==='changes' ? 'bg-slate-700/70 text-slate-100' : 'text-slate-400 hover:text-slate-200'"
                                            class="px-2 py-1 font-medium">Changes</button>
                                    <button @click="tab='before'"
                                            :class="tab==='before' ? 'bg-slate-700/70 text-slate-100' : 'text-slate-400 hover:text-slate-200'"
                                            class="px-2 py-1 font-medium">Before</button>
                                    <button @click="tab='after'"
                                            :class="tab==='after' ? 'bg-slate-700/70 text-slate-100' : 'text-slate-400 hover:text-slate-200'"
                                            class="px-2 py-1 font-medium">After</button>
                                    <button @click="tab='side'"
                                            :class="tab==='side' ? 'bg-slate-700/70 text-slate-100' : 'text-slate-400 hover:text-slate-200'"
                                            class="px-2 py-1 font-medium hidden md:inline-flex">Side-by-Side</button>
                                </div>
                                <div class="flex items-center gap-2 text-[11px] grow min-w-[12rem]"
                                     x-show="tab==='changes'">
                                    <div class="relative flex-1">
                                        <iconify-icon icon="lucide:search" class="text-slate-500 absolute left-1.5 top-1/2 -translate-y-1/2" inline></iconify-icon>
                                        <input x-model="filter"
                                               placeholder="Filter path…"
                                               class="w-full pl-6 pr-2 py-1 rounded-md bg-slate-900/60 border border-slate-700/70 focus:border-sky-500 focus:outline-none placeholder:text-slate-600" />
                                    </div>
                                    <label class="inline-flex items-center gap-1 cursor-pointer select-none">
                                        <input type="checkbox"
                                               x-model="showUnchanged"
                                               class="w-3.5 h-3.5 rounded border-slate-600 bg-slate-800 text-sky-500 focus:ring-0" />
                                        <span class="text-slate-400">Unchanged</span>
                                    </label>
                                </div>
                                <div class="flex items-center gap-1 ml-auto">
                                    <button @click="copyJson(item.before_state)"
                                            class="px-2 py-1 rounded-md bg-slate-800 hover:bg-slate-700 text-[11px] text-slate-300 flex items-center gap-1"
                                            title="Copy Before JSON">
                                        <iconify-icon icon="lucide:copy" inline></iconify-icon><span>Before</span>
                                    </button>
                                    <button @click="copyJson(item.after_state)"
                                            class="px-2 py-1 rounded-md bg-slate-800 hover:bg-slate-700 text-[11px] text-slate-300 flex items-center gap-1"
                                            title="Copy After JSON">
                                        <iconify-icon icon="lucide:copy" inline></iconify-icon><span>After</span>
                                    </button>
                                </div>
                            </div>
                            <!-- Panels -->
                            <div class="space-y-3">
                                <div class="overflow-auto" :class="tab==='side' ? '' : 'space-y-3'">
                                    <!-- Changes Tab -->
                                    <template x-if="tab==='changes'">
                                        <div>
                                            <template x-if="filteredChanges.length">
                                                <ul class="text-[11px] divide-y divide-slate-800/60">
                                                    <template x-for="d in filteredChanges" :key="d.path">
                                                        <li class="py-1.5 px-1 group">
                                                            <div class="flex flex-wrap items-start gap-2">
                                                                <span class="px-1.5 py-0.5 rounded bg-slate-800/80 group-hover:bg-slate-700/80 text-slate-300 font-mono text-[10px] max-w-full break-all"
                                                                      x-text="d.path"></span>
                                                                <div class="flex items-start gap-1.5 flex-1 min-w-[10rem]">
                                                                    <span class="min-w-0 break-all"
                                                                          :class="d.status==='removed' ? 'text-red-400' : d.status==='changed' ? 'text-red-300' : 'text-slate-500'"
                                                                          x-text="truncateValue(d.before)"></span>
                                                                    <iconify-icon icon="lucide:arrow-right" class="mt-0.5 text-slate-600 shrink-0" inline></iconify-icon>
                                                                    <span class="min-w-0 break-all"
                                                                          :class="d.status==='added' ? 'text-emerald-400' : d.status==='changed' ? 'text-emerald-300' : 'text-slate-500'"
                                                                          x-text="truncateValue(d.after)"></span>
                                                                </div>
                                                            </div>
                                                        </li>
                                                    </template>
                                                </ul>
                                            </template>
                                            <p x-show="!filteredChanges.length"
                                               class="text-[11px] text-slate-500 italic">No differences.</p>
                                        </div>
                                    </template>
                                    <!-- Before Tab -->
                                    <template x-if="tab==='before'">
                                        <div class="space-y-2">
                                            <h5 class="text-xs font-semibold uppercase tracking-wider text-slate-400">State Before</h5>
                                            <pre class="text-[11px] leading-tight bg-slate-900/80 border border-slate-800 rounded-md p-2 overflow-auto max-h-72"
                                                 x-html="highlightJson(item.before_state)"></pre>
                                        </div>
                                    </template>
                                    <!-- After Tab -->
                                    <template x-if="tab==='after'">
                                        <div class="space-y-2">
                                            <h5 class="text-xs font-semibold uppercase tracking-wider text-slate-400">State After</h5>
                                            <pre class="text-[11px] leading-tight bg-slate-900/80 border border-slate-800 rounded-md p-2 overflow-auto max-h-72"
                                                 x-html="highlightJson(item.after_state)"></pre>
                                        </div>
                                    </template>
                                    <!-- Side-by-Side Tab -->
                                    <template x-if="tab==='side'">
                                        <div class="grid md:grid-cols-2 gap-2 md:gap-3 items-start">
                                            <div class="space-y-1.5">
                                                <h5 class="text-xs font-semibold uppercase tracking-wider text-slate-400 flex items-center gap-1">
                                                    Before <span class="text-[10px] font-normal text-slate-600" x-text="beforeSize"></span>
                                                </h5>
                                                <pre class="text-[11px] leading-tight bg-slate-900/80 border border-slate-800 rounded-md p-2 overflow-auto max-h-64"
                                                     x-html="highlightJson(item.before_state)"></pre>
                                            </div>
                                            <div class="space-y-1.5">
                                                <h5 class="text-xs font-semibold uppercase tracking-wider text-slate-400 flex items-center gap-1">
                                                    After <span class="text-[10px] font-normal text-slate-600" x-text="afterSize"></span>
                                                </h5>
                                                <pre class="text-[11px] leading-tight bg-slate-900/80 border border-slate-800 rounded-md p-2 overflow-auto max-h-64"
                                                     x-html="highlightJson(item.after_state)"></pre>
                                            </div>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
        <p x-show="!items.length && !loadingInitial"
           class="text-sm text-slate-500">No history yet.</p>
        <div class="flex justify-center mt-4"
             x-show="!allLoaded && !loadingInitial">
            <button @click="loadMore()"
                    :disabled="loadingMore"
                    class="px-3 py-1.5 rounded-md text-[12px] font-medium bg-slate-800 hover:bg-slate-700 disabled:opacity-40 border border-slate-700 text-slate-200 flex items-center gap-2">
                <iconify-icon :icon="loadingMore ? 'lucide:loader-2' : 'lucide:download'" :class="loadingMore ? 'animate-spin' : ''" inline></iconify-icon>
                <span x-text="loadingMore ? 'Loading…' : 'Load More'"></span>
            </button>
        </div>
        <div x-ref="sentinel" class="h-4"></div>
        <!-- Jump to Latest Floating Button -->
        <div x-show="showJump"
             x-transition:enter="transition ease-out duration-200"
             x-transition:enter-start="opacity-0 translate-y-2 scale-95"
             x-transition:enter-end="opacity-100 translate-y-0 scale-100"
             x-transition:leave="transition ease-in duration-150"
             x-transition:leave-start="opacity-100 translate-y-0 scale-100"
             x-transition:leave-end="opacity-0 translate-y-2 scale-95"
             class="fixed right-6 bottom-6 md:right-8 md:bottom-8 z-40 pointer-events-none">
            <button @click="jumpToLatest()"
                    :class="['group relative pointer-events-auto flex items-center gap-2 pl-3 pr-3 py-2 text-sm font-medium rounded-md border shadow-md shadow-slate-950/40 backdrop-blur-md focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-400/70 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-900 transition', newItemsCount>0 ? 'border-sky-500/60 bg-gradient-to-r from-sky-600 to-sky-500 text-white hover:from-sky-500 hover:to-sky-400' : 'border-slate-600/60 bg-slate-800/70 hover:bg-slate-700/70 text-slate-100']"
                    aria-label="Jump to latest"
                    title="Jump to latest">
                <iconify-icon icon="lucide:arrow-up" class="opacity-90 group-hover:opacity-100" inline></iconify-icon>
                <span class="hidden sm:inline" x-text="newItemsCount>0 ? 'Latest' : 'Top'"></span>
                <span x-show="newItemsCount>0"
                      x-transition
                      class="text-[10px] font-semibold inline-flex items-center justify-center leading-none h-5 min-w-5 px-1 rounded-md bg-slate-900/70 border border-white/20 text-white shadow ring-1 ring-sky-300/40">
                    <span x-text="newItemsCount"></span>
                </span>
                <span class="absolute inset-0 rounded-md ring-1 ring-inset ring-white/5 group-hover:ring-white/15"></span>
            </button>
        </div>
    </div>
    <script>
        function timeline(profile) {
            return {
                // State
                profile,
                items: [],
                stats: {},
                media: {},
                plexMedia: {},
                outcomeFilter: null,
                perPage: 50,
                page: 1,
                pages: 1,
                total: 0,
                loadingInitial: false,
                loadingMore: false,
                error: null,
                newItemsCount: 0,
                showJump: false,
                _knownIds: new Set(),
                ws: null,
                // Helpers
                buildQuery(page) {
                    const params = new URLSearchParams({
                        page: String(page),
                        per_page: String(this.perPage)
                    });
                    if (this.outcomeFilter) params.set('outcome', this.outcomeFilter);
                    return `/api/history/${this.profile}?${params.toString()}`;
                },
                orderedStats() {
                    const order = ['synced', 'failed', 'not_found', 'deleted', 'pending', 'skipped'];
                    const entries = Object.entries(this.stats);
                    entries.sort((a, b) => order.indexOf(a[0]) - order.indexOf(b[0]));
                    return Object.fromEntries(entries);
                },
                reload() {
                    this.loadFirst();
                },
                // Data loading
                loadFirst() {
                    this.page = 1;
                    this.items = [];
                    this.pages = 1;
                    this.total = 0;
                    this.error = null;
                    this.loadingInitial = true;
                    fetch(this.buildQuery(1))
                        .then(r => {
                            if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
                            return r.json();
                        })
                        .then(d => {
                            this.items = d.items || [];
                            this.stats = d.stats || {};
                            this.total = d.total || 0;
                            this.pages = d.pages || 1;
                            this.page = d.page || 1;
                            this.perPage = d.per_page || this.perPage;
                            this._knownIds = new Set(this.items.map(i => i.id));
                            this.newItemsCount = 0;
                            this.fetchMedia();
                        })
                        .catch(e => {
                            this.error = String(e);
                            try {
                                if (window.notify && notify.toast) notify.toast('Failed to load history: ' + (e?.message || e), 'error');
                            } catch (_) {}
                        })
                        .finally(() => {
                            this.loadingInitial = false;
                        });
                },
                loadMore() {
                    if (this.loadingMore || this.page >= this.pages) return;
                    this.loadingMore = true;
                    const next = this.page + 1;
                    fetch(this.buildQuery(next))
                        .then(r => {
                            if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
                            return r.json();
                        })
                        .then(d => {
                            const existing = new Set(this.items.map(i => i.id));
                            const newOnes = (d.items || []).filter(i => !existing.has(i.id));
                            this.items = [...this.items, ...newOnes];
                            this.stats = d.stats || this.stats;
                            this.total = d.total || this.total;
                            this.pages = d.pages || this.pages;
                            this.page = d.page || next;
                            this.perPage = d.per_page || this.perPage;
                            newOnes.forEach(i => this._knownIds.add(i.id));
                            this.fetchMedia();
                        })
                        .catch(e => {
                            this.error = String(e);
                            try {
                                if (window.notify && notify.toast) notify.toast('Failed to load more: ' + (e?.message || e), 'error');
                            } catch (_) {}
                        })
                        .finally(() => {
                            this.loadingMore = false;
                        });
                },
                setupInfiniteScroll() {
                    this.$nextTick(() => {
                        const el = this.$refs.sentinel;
                        if (!el) return;
                        const obs = new IntersectionObserver(entries => {
                            entries.forEach(en => {
                                if (en.isIntersecting) this.loadMore();
                            });
                        }, {
                            root: null,
                            rootMargin: '0px 0px 300px 0px',
                            threshold: 0
                        });
                        obs.observe(el);
                        this._sentinelObserver = obs;
                    });
                },
                get allLoaded() {
                    return this.page >= this.pages;
                },
                filteredItems() {
                    return this.items;
                },
                toggleOutcomeFilter(o) {
                    this.outcomeFilter = this.outcomeFilter === o ? null : o;
                    this.loadFirst();
                },
                // WebSocket for live updates (unfiltered baseline)
                openWs() {
                    const url = getWsBase() + `/ws/history/${this.profile}`;
                    this.ws = new WebSocket(url);
                    this.ws.onmessage = ev => {
                        if (this.outcomeFilter) return; // ignore live merges when filtered server-side
                        const d = JSON.parse(ev.data);
                        const latest = d.items || [];
                        if (!latest.length) return;
                        const latestIds = new Set(latest.map(i => i.id));
                        const rest = this.items.filter(i => !latestIds.has(i.id));
                        this.items = [...latest, ...rest];
                        this.stats = d.stats || this.stats;
                        let added = 0;
                        latest.forEach(i => {
                            if (!this._knownIds.has(i.id)) {
                                this._knownIds.add(i.id);
                                added++;
                            }
                        });
                        if (added && !this.isNearTop()) {
                            this.newItemsCount += added;
                            this.showJump = true;
                        } else if (this.isNearTop()) {
                            this.newItemsCount = 0;
                        }
                        this.fetchMedia();
                    };
                    this.ws.onclose = () => setTimeout(() => this.openWs(), 3000);
                },
                isNearTop() {
                    return window.scrollY < 120;
                },
                onScroll() {
                    const nearTop = this.isNearTop();
                    if (nearTop) this.newItemsCount = 0;
                    this.showJump = !nearTop || this.newItemsCount > 0;
                },
                jumpToLatest() {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                    setTimeout(() => {
                        this.newItemsCount = 0;
                        this.onScroll();
                    }, 400);
                },
                sync(poll) {
                    fetch(`/api/sync/${this.profile}?poll=${poll}`, {
                            method: 'POST'
                        })
                        .then(r => {
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            try {
                                if (window.notify && notify.toast) notify.toast('Sync started', 'info');
                            } catch (_) {}
                        })
                        .catch(e => {
                            try {
                                if (window.notify && notify.toast) notify.toast('Sync failed: ' + (e?.message || e), 'error');
                            } catch (_) {}
                        });
                },
                fetchMedia() {
                    // AniList
                    const ids = [...new Set(this.items.filter(i => i.anilist_id).map(i => i.anilist_id))];
                    const missing = ids.filter(id => !this.media[id]);
                    if (missing.length && window.AniList && typeof AniList.fetch === 'function') {
                        AniList.fetch(missing).then(data => {
                                this.media = {
                                    ...this.media,
                                    ...data
                                };
                            })
                            .catch(err => {
                                missing.forEach(id => {
                                    this.media[id] = {
                                        _error: true,
                                        message: String(err)
                                    };
                                });
                            });
                    }
                    // Plex
                    const plexGuids = [...new Set(this.items.filter(i => i.plex_guid).map(i => i.plex_guid))];
                    const missingPlex = plexGuids.filter(g => !this.plexMedia[g]);
                    if (missingPlex.length && window.Plex && typeof Plex.fetch === 'function') {
                        Plex.fetch(missingPlex).then(data => {
                                this.plexMedia = {
                                    ...this.plexMedia,
                                    ...data
                                };
                            })
                            .catch(err => {
                                missingPlex.forEach(g => {
                                    this.plexMedia[g] = {
                                        _error: true,
                                        message: String(err)
                                    };
                                });
                            });
                    }
                },
                anilistUrl(item) {
                    return item.anilist_id ? `https://anilist.co/anime/${item.anilist_id}` : null;
                },
                plexUrl(item) {
                    try {
                        if (!window.PLEX_SERVER_MACHINE_ID) {
                            if (!item.plex_guid) return null;
                            const key = encodeURIComponent(`/library/metadata/${this.shortGuid(item.plex_guid)}`);
                            return `https://app.plex.tv/desktop/#!/provider/tv.plex.provider.discover/details?key=${key}`;
                        } else {
                            if (!item.plex_rating_key) return null;
                            const key = encodeURIComponent(`/library/metadata/${item.plex_rating_key}`);
                            return `https://app.plex.tv/desktop#!/server/${window.PLEX_SERVER_MACHINE_ID}/details?key=${key}`;
                        }
                    } catch {
                        return null;
                    }
                },
                shortGuid(g) {
                    if (!g) return '';
                    return g.split('/').pop();
                },
                copy(text) {
                    try {
                        navigator.clipboard.writeText(text);
                    } catch {}
                },
                displayTitle(item) {
                    if (item.anilist_id) {
                        const m = this.media[item.anilist_id];
                        if (!m) return 'Loading…';
                        if (m._error) return `AniList ${item.anilist_id}`;
                        try {
                            const t = (window.AniList && typeof AniList.getTitle === 'function') ? AniList.getTitle(m, null) : null;
                            if (t) return t;
                        } catch {}
                        return `AniList ${item.anilist_id}`;
                    }
                    if (item.plex_guid) {
                        const p = this.plexMedia[item.plex_guid];
                        if (!p) return 'Loading…';
                        if (p._error) return `Plex ${this.shortGuid(item.plex_guid)}`;
                        if (p.title) return p.title;
                        return `Plex ${this.shortGuid(item.plex_guid)}`;
                    }
                    return 'Unmapped Item';
                },
                titleSource(item) {
                    if (item.anilist_id) {
                        const m = this.media[item.anilist_id];
                        if (m && !m._error) return 'AniList';
                        if (item.plex_guid) {
                            const p = this.plexMedia[item.plex_guid];
                            if (p && !p._error) return 'Plex';
                        }
                        return 'AniList';
                    }
                    if (item.plex_guid) {
                        const p = this.plexMedia[item.plex_guid];
                        if (p && !p._error) return 'Plex';
                        return 'Plex';
                    }
                    return 'Unknown';
                },
                badgeColor(o) {
                    return {
                        failed: 'bg-red-600 text-white',
                        synced: 'bg-emerald-600 text-white',
                        not_found: 'bg-amber-600 text-white',
                        deleted: 'bg-fuchsia-600 text-white',
                        pending: 'bg-slate-600 text-white',
                        skipped: 'bg-slate-700 text-white'
                    } [o] || 'bg-slate-700 text-white';
                },
                outcomeIcon(o) {
                    return {
                        failed: 'x-circle',
                        synced: 'check-circle-2',
                        not_found: 'search-x',
                        deleted: 'trash-2',
                        pending: 'clock',
                        skipped: 'skip-forward'
                    } [o] || 'circle';
                },
                outcomeLabel(o) {
                    if (!o) return '';
                    return o.replace(/_/g, ' ').toUpperCase();
                },
                formatState(obj) {
                    return obj ? JSON.stringify(obj, null, 2) : '—';
                },
                truncateValue(v) {
                    if (v === null) return 'null';
                    if (v === undefined) return 'undefined';
                    const s = typeof v === 'string' ? v : JSON.stringify(v);
                    return s.length > 60 ? s.slice(0, 57) + '…' : s;
                },
                diffState(item) {
                    const before = item.before_state || {};
                    const after = item.after_state || {};
                    const paths = new Set([...this._walkPaths(before), ...this._walkPaths(after)]);
                    const diffs = [];
                    paths.forEach(p => {
                        const bv = this._getPath(before, p);
                        const av = this._getPath(after, p);
                        if (JSON.stringify(bv) !== JSON.stringify(av)) diffs.push({
                            path: p,
                            before: bv,
                            after: av
                        });
                    });
                    return diffs;
                },
                _walkPaths(obj, base = '') {
                    const paths = [];
                    if (obj && typeof obj === 'object') {
                        Object.keys(obj).forEach(k => {
                            const val = obj[k];
                            const path = base ? base + '.' + k : k;
                            if (val && typeof val === 'object' && !Array.isArray(val)) paths.push(...this._walkPaths(val, path));
                            else paths.push(path);
                        });
                    }
                    return paths;
                },
                _getPath(obj, path) {
                    return path.split('.').reduce((o, k) => (o && k in o) ? o[k] : undefined, obj);
                },
                // Lifecycle
                init() {
                    this.loadFirst();
                    this.openWs();
                    this.setupInfiniteScroll();
                    this.onScroll = this.onScroll.bind(this);
                    window.addEventListener('scroll', this.onScroll, {
                        passive: true
                    });
                }
            }
        }

        function diffViewer(item) {
            return {
                item,
                tab: 'changes',
                filter: '',
                showUnchanged: false,
                // expanded view removed
                get changes() {
                    // derive full list with status (added/removed/changed/unchanged)
                    const before = this.item.before_state || {};
                    const after = this.item.after_state || {};
                    const paths = new Set();
                    const walk = (obj, base = '') => {
                        if (obj && typeof obj === 'object') {
                            Object.keys(obj).forEach(k => {
                                const val = obj[k];
                                const path = base ? base + '.' + k : k;
                                if (val && typeof val === 'object' && !Array.isArray(val)) {
                                    walk(val, path);
                                } else {
                                    paths.add(path);
                                }
                            });
                        }
                    };
                    walk(before);
                    walk(after);
                    const out = [];
                    paths.forEach(p => {
                        const bv = p.split('.').reduce((o, k) => (o && k in o) ? o[k] : undefined, before);
                        const av = p.split('.').reduce((o, k) => (o && k in o) ? o[k] : undefined, after);
                        let status = 'unchanged';
                        if (bv === undefined && av !== undefined) status = 'added';
                        else if (bv !== undefined && av === undefined) status = 'removed';
                        else if (JSON.stringify(bv) !== JSON.stringify(av)) status = 'changed';
                        out.push({
                            path: p,
                            before: bv,
                            after: av,
                            status
                        });
                    });
                    // sort: changed, added, removed, unchanged
                    const order = {
                        changed: 0,
                        added: 1,
                        removed: 2,
                        unchanged: 3
                    };
                    out.sort((a, b) => order[a.status] - order[b.status] || a.path.localeCompare(b.path));
                    return out;
                },
                get filteredChanges() {
                    return this.changes.filter(c => {
                        if (!this.showUnchanged && c.status === 'unchanged') return false;
                        if (this.filter && !c.path.toLowerCase().includes(this.filter.toLowerCase())) return false;
                        return true;
                    });
                },
                get beforeSize() {
                    return this.sizeLabel(this.item.before_state);
                },
                get afterSize() {
                    return this.sizeLabel(this.item.after_state);
                },
                sizeLabel(obj) {
                    if (!obj) return '0 keys';
                    let count = 0;
                    const scan = o => {
                        if (o && typeof o === 'object') Object.keys(o).forEach(k => {
                            count++;
                            if (o[k] && typeof o[k] === 'object' && !Array.isArray(o[k])) scan(o[k]);
                        });
                    };
                    scan(obj);
                    return count + ' keys';
                },
                truncateValue(v) {
                    if (v === null) return 'null';
                    if (v === undefined) return 'undefined';
                    const s = typeof v === 'string' ? v : JSON.stringify(v);
                    return s.length > 120 ? s.slice(0, 117) + '…' : s;
                },
                highlightJson(obj) {
                    if (!obj) return '<span class="text-slate-600">—</span>';
                    const json = JSON.stringify(obj, null, 2);
                    return json.replace(/(&|<)/g, c => c === '&' ? '&amp;' : '&lt;').replace(/("(\\.|[^"])*"\s*:)|("(\\.|[^"])*")|\b(true|false|null)\b|-?\b\d+(?:\.\d+)?\b/g, m => {
                        if (/^".*":$/.test(m)) return `<span class='text-sky-300'>${m}</span>`;
                        if (/^"/.test(m)) return `<span class='text-emerald-300'>${m}</span>`;
                        if (/true|false/.test(m)) return `<span class='text-indigo-300'>${m}</span>`;
                        if (/null/.test(m)) return `<span class='text-pink-300'>${m}</span>`;
                        return `<span class='text-amber-300'>${m}</span>`;
                    });
                },
                copyJson(obj) {
                    try {
                        navigator.clipboard.writeText(JSON.stringify(obj, null, 2));
                    } catch {}
                },
                init() {}
            }
        }
    </script>
{% endblock content %}
