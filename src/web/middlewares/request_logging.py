"""Middlewares for handling requests and responses."""

import time
from collections.abc import Callable
from io import BytesIO

from fastapi.responses import Response
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request

from src import log

__all__ = ["RequestLoggingMiddleware"]


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Middleware to log all incoming requests and responses."""

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Process the incoming request, log details, and capture the response.

        Args:
            request (Request): The incoming HTTP request.
            call_next (Callable): Function to call the next middleware or endpoint.

        Returns:
            Response: The HTTP response generated by the endpoint.
        """
        start_time = time.time()

        request_info = (
            f"{request.method} {request.url.path}"
            f"{f'?{request.url.query}' if request.url.query else ''} "
            f"from {request.client.host if request.client else 'unknown'}"
        )

        # Capture request body without consuming the stream
        body_info = ""
        if request.method in ("POST", "PUT", "PATCH"):
            try:
                body = await request.body()

                request._body = body
                request.scope["body"] = BytesIO(body)

                if body:
                    content_type = request.headers.get("content-type", "").lower()
                    if "application/json" in content_type or "text/" in content_type:
                        try:
                            body_str = body.decode("utf-8")
                            if len(body_str) > 1000:
                                body_str = body_str[:1000] + "..."
                            body_info = f" Body: {body_str}"
                        except UnicodeDecodeError:
                            body_info = f" Body: <binary data, {len(body)} bytes>"
                    else:
                        body_info = (
                            f" Body: <{content_type or 'unknown'}, {len(body)} bytes>"
                        )
            except Exception as e:
                body_info = f" Body: <error reading: {e}>"

        full_request_info = request_info + body_info

        try:
            response = await call_next(request)
            process_time = time.time() - start_time

            log.debug(
                f"Request: {full_request_info} -> "
                f"Response: {response.status_code} ({process_time:.3f}s)"
            )

            return response
        except Exception:
            process_time = time.time() - start_time
            log.debug(f"Request: {full_request_info} -> Failed ({process_time:.3f}s)")
            raise
