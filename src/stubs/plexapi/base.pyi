from collections.abc import Generator
from functools import cached_property as cached_property
from typing import Generic, Iterable, TypeVar
from xml.etree.ElementTree import Element, ElementTree

from _typeshed import Incomplete

from plexapi.server import PlexServer

PlexObjectT = TypeVar("PlexObjectT", bound="PlexObject")
MediaContainerT = TypeVar("MediaContainerT", bound="MediaContainer")
USER_DONT_RELOAD_FOR_KEYS: Incomplete
OPERATORS: Incomplete

class PlexObject:
    TAG: Incomplete
    TYPE: Incomplete
    key: Incomplete
    _server: PlexServer
    def __init__(
        self,
        server,
        data,
        initpath: Incomplete | None = None,
        parent: Incomplete | None = None,
    ) -> None: ...
    def __setattr__(self, attr, value) -> None: ...
    def fetchItems(
        self,
        ekey,
        cls: Incomplete | None = None,
        container_start: Incomplete | None = None,
        container_size: Incomplete | None = None,
        maxresults: Incomplete | None = None,
        params: Incomplete | None = None,
        **kwargs,
    ): ...
    def fetchItem(self, ekey, cls: Incomplete | None = None, **kwargs): ...
    def findItems(
        self,
        data,
        cls: Incomplete | None = None,
        initpath: Incomplete | None = None,
        rtag: Incomplete | None = None,
        **kwargs,
    ): ...
    def findItem(
        self,
        data,
        cls: Incomplete | None = None,
        initpath: Incomplete | None = None,
        rtag: Incomplete | None = None,
        **kwargs,
    ): ...
    def firstAttr(self, *attrs): ...
    def listAttrs(self, data, attr, rtag: Incomplete | None = None, **kwargs): ...
    def reload(self, key: str | None = None, **kwargs): ...
    def _reload(
        self, key: str | None = None, _overwriteNone: bool = True, **kwargs
    ): ...
    def _loadData(self, data: ElementTree) -> None: ...

class PlexPartialObject(PlexObject):
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __iter__(self): ...
    def __getattribute__(self, attr): ...
    def analyze(self) -> None: ...
    def isFullObject(self): ...
    def isPartialObject(self): ...
    def isLocked(self, field: str): ...
    def edit(self, **kwargs): ...
    def batchEdits(self): ...
    def saveEdits(self): ...
    def refresh(self) -> None: ...
    def section(self): ...
    def delete(self): ...
    def history(
        self, maxresults: Incomplete | None = None, mindate: Incomplete | None = None
    ): ...
    def getWebURL(self, base: Incomplete | None = None): ...
    def playQueue(self, *args, **kwargs): ...

class Playable:
    def getStreamURL(self, **kwargs): ...
    def iterParts(self) -> Generator[Incomplete]: ...
    def videoStreams(self): ...
    def audioStreams(self): ...
    def subtitleStreams(self): ...
    def lyricStreams(self): ...
    def play(self, client) -> None: ...
    def download(
        self,
        savepath: Incomplete | None = None,
        keep_original_name: bool = False,
        **kwargs,
    ): ...
    def updateProgress(self, time, state: str = "stopped"): ...
    def updateTimeline(
        self, time, state: str = "stopped", duration: Incomplete | None = None
    ): ...

class PlexSession:
    @cached_property
    def user(self): ...
    def source(self): ...
    def stop(self, reason: str = ""): ...

class PlexHistory:
    def source(self): ...
    def delete(self): ...

class MediaContainer(list[PlexObjectT], PlexObject, Generic[PlexObjectT]):
    TAG: str
    def __init__(
        self,
        server: PlexServer,
        data: Element,
        *args: PlexObjectT,
        initpath: str | None = None,
        parent: PlexObject | None = None,
    ) -> None: ...
    totalSize: Incomplete
    size: Incomplete
    offset: Incomplete
    def extend(
        self, /, __iterable: Iterable[PlexObjectT] | MediaContainer[PlexObjectT]
    ) -> None: ...
